//*************************************************************************************************
// メッシュドーム処理 (meshDome.cpp)
// Author : YUHEI KAN
//*************************************************************************************************

//*************************************************************************************************
// インクルードファイル
//*************************************************************************************************
#include "scene.h"
#include "scene3D.h"
#include "meshDome.h"

//*************************************************************************************************
// マクロ定義 
//*************************************************************************************************
#define TEXTURENAME00 "data/TEXTURE/GAME/skyDome/sky004.jpg" //読み込むテクスチャの名前
#define DEGENERATE_NUM      ( 2 )                    //縮退ポリゴンによる頂点数増分(縦の分割数によって比例)

//*************************************************************************************************
// 構造体
//*************************************************************************************************

//*************************************************************************************************
// クラス
//*************************************************************************************************

//*************************************************************************************************
// グローバル変数
//*************************************************************************************************

//*************************************************************************************************
// プロトタイプ宣言
//*************************************************************************************************

//*************************************************************************************************
// メッシュドームのコンストラクタ
//*************************************************************************************************
CMeshDome::CMeshDome ( int nPriority ):CScene3D ( SCENE_TYPE_MESHDOME, nPriority )
{
}

//*************************************************************************************************
// メッシュドームのデストラクタ
//*************************************************************************************************
CMeshDome::~CMeshDome ()
{
}

//*************************************************************************************************
// 初期化処理
//*************************************************************************************************
HRESULT CMeshDome::Init(void)
{
    //変数宣言
    D3DXVECTOR3 Pos = D3DXVECTOR3 ( m_Pos.x, m_Pos.y, m_Pos.z );                //ブロックの位置
    D3DXVECTOR2 Tex = D3DXVECTOR2 ( 0.0f, 0.0f );                               //テクスチャUV値
    int nNumVertex;                                                             //作成したい頂点数
    int nNumIndex;                                                              //作成したいインデックス数
    int nDegree_V;                                                              //計算用角度(V値用)
    int nDegree_U;                                                              //計算用角度(U値用)
    int nNumBlock;                                                              //ブロックの数

    //Direct3Dデバイスの取得
    LPDIRECT3DDEVICE9 pDevice = CRenderer::GetDevice ( );

    //Direct3DデバイスのNULLチェック
    if ( pDevice != NULL )
    {
        //作成したい頂点数の設定
        nNumVertex = (m_nV+1) * (m_nU+1);

        //頂点バッファの作成
        if ( FAILED (pDevice->CreateVertexBuffer ( 
            sizeof ( VERTEX_3D ) * nNumVertex,      //頂点バッファのサイズ
            D3DUSAGE_WRITEONLY,                     //VertexBufferの使い方を指定
            FVF_VERTEX_3D,                          //頂点フォーマット
            D3DPOOL_MANAGED,                        //メモリ管理方法
            &m_pVtxBuffer,                          //頂点バッファ管理インターフェースポインタのアドレス
            NULL ) ) )
        {
            return E_FAIL;
        }

        //作成したいインデックス数の設定
        nNumIndex = m_nV * ( DEGENERATE_NUM * m_nU + 4 ) - 2;

        //インデックスバッファの作成
        if ( FAILED (pDevice->CreateIndexBuffer ( 
        sizeof ( WORD ) * nNumIndex,            //インデックスバッファのサイズ
        D3DUSAGE_WRITEONLY,                     //使用フラグ
        D3DFMT_INDEX16,                         //インデックスデータフォーマット
        D3DPOOL_MANAGED,                        //メモリの管理方法
        &m_pIdxBuffer,                          //インデックスバッファインターフェースポインタのアドレス
        NULL ) ) )
        {
            return E_FAIL;
        }

        // テクスチャの生成
        if ( FAILED ( D3DXCreateTextureFromFile ( pDevice, TEXTURENAME00, &m_pTexture ) ) )
        {
            MessageBox ( NULL, "テクスチャの読み込みに失敗しました", "終了メッセージ", MB_OK );
        }
    }

    VERTEX_3D* pVtx;                            //仮想アドレス頂点用ポインタ

    //頂点バッファをロックして、仮想アドレスを取得する
    m_pVtxBuffer->Lock ( 0, 0, (void**)&pVtx, 0 );

    //天辺の座標を設定
    Pos = D3DXVECTOR3 ( m_Pos.x, m_Pos.y + m_fRadius, m_Pos.z );

    //メッシュドームのU値分割数分繰り返す
    for ( int i = 0; i < m_nU+1; i++ )
    {
        //頂点情報設定開始-------------------------------------------

        //変数宣言
        D3DXVECTOR3 VecNormal;                      //法線ベクトル

        //円周上の座標-中心座標
        VecNormal.x = Pos.x - m_Pos.x;
        VecNormal.y = Pos.y - m_Pos.y;
        VecNormal.z = Pos.z - m_Pos.z;

        //ベクトルの向きはそのままでt単位ベクトルを作る
        D3DXVec3Normalize ( &VecNormal, &VecNormal );

        //頂点座標の設定(3D座標)
        pVtx[i].pos = Pos;

        //ライトベクトルの設定
        pVtx[i].normal = VecNormal;

        //頂点カラー(0～255の整数値)
        pVtx[i].color = D3DCOLOR_RGBA( 255, 255, 255, 255 );

        //テクスチャ座標の設定
        pVtx[i].tex = Tex;

        //頂点情報設定終了-------------------------------------------

        //テクスチャ座標の更新
        Tex.x += 1.0f / m_nU;
    }

    //計算用角度(V値用)初期化
    nDegree_V = 360;

    //頂点数分繰り返す
    for ( int i = 0; i < nNumVertex-m_nU-1; i++ )
    {
        //一周分の座標を設定したら角度更新
        if ( i%(m_nU+1) == 0 )
        {
            //0°から90°に向かって角度を増やす(V値用)
            nDegree_V += 90 / m_nV;

            //計算用角度(U値用)初期化
            nDegree_U = 360;

            //テクスチャ座標の初期化
            Tex.x = 0.0f;
            Tex.y += 1.0f / m_nV;
        }

        //座標更新
        Pos = D3DXVECTOR3 ( m_fRadius * sinf ( nDegree_V * D3DX_PI/180.0f ) * cosf ( nDegree_U * D3DX_PI/180.0f ),
                            m_fRadius * cosf ( nDegree_V * D3DX_PI/180.0f ),
                            m_fRadius * sinf ( nDegree_V * D3DX_PI/180.0f ) * sinf ( nDegree_U * D3DX_PI/180.0f ) );

        //頂点情報設定開始-------------------------------------------

        //変数宣言
        D3DXVECTOR3 VecNormal;                      //法線ベクトル

        //円周上の座標-中心座標
        VecNormal.x = Pos.x - m_Pos.x;
        VecNormal.y = Pos.y - m_Pos.y;
        VecNormal.z = Pos.z - m_Pos.z;

        //ベクトルの向きはそのままでt単位ベクトルを作る
        D3DXVec3Normalize ( &VecNormal, &VecNormal );

        //頂点座標の設定(3D座標)
        pVtx[i + m_nU+1].pos = Pos;

        //ライトベクトルの設定
        pVtx[i + m_nU+1].normal = VecNormal;

        //頂点カラー(0～255の整数値)
        pVtx[i + m_nU+1].color = D3DCOLOR_RGBA( 255, 255, 255, 255 );

        //テクスチャ座標の設定
        pVtx[i + m_nU+1].tex = Tex;

        //頂点情報設定終了-------------------------------------------

        //360°から0°に向かって角度を増やす(U値用)
        nDegree_U -= 360 / m_nU;

        //テクスチャ座標の更新
        Tex.x += 1.0f / m_nU;
    }

    //頂点バッファのロックを解除
    m_pVtxBuffer->Unlock ( );

    WORD* pIdx;                                 //仮想アドレスインデックス用ポインタ

    //インデックスバッファをロックして、仮想アドレスを取得する
    m_pIdxBuffer->Lock ( 0, 0, (void**)&pIdx, 0 );

    //ブロックの数の設定
    nNumBlock = m_nV * m_nU;

    //インデックスの数分繰り返す
    for ( int i = 0; i < nNumBlock; i++ )
    {
        //インデックス情報設定開始-----------------------------------------

        //変数宣言
        int j;                                      //何行目か

        //現在何行目かの設定
        j = i / m_nU;

        //バーテックスバッファの頂点情報をインデックスに設定
        pIdx[ 0 + i * 2 + j * 4 ] = j+i+(m_nU+1);
        pIdx[ 1 + i * 2 + j * 4 ] = j+i;
        pIdx[ 2 + i * 2 + j * 4 ] = j+i+(m_nU+1)+1;
        pIdx[ 3 + i * 2 + j * 4 ] = j+i+1;

        //縮退ポリゴン
        if ( i % m_nU == 0 && i != 0 )
        {
            pIdx[ -2 + i * 2 + j * 4 ] = pIdx[ -3 + i * 2 + j * 4 ];
            pIdx[ -1 + i * 2 + j * 4 ] = pIdx[ 0 + i * 2 + j * 4 ];
        }

        //インデックス情報設定終了-----------------------------------------
    }

    //インデックスバッファのロックを解除
    m_pIdxBuffer->Unlock ( );

    return S_OK;
}

//*************************************************************************************************
// 終了処理
//*************************************************************************************************
void CMeshDome::Uninit(void)
{
}

//*************************************************************************************************
// 更新処理
//*************************************************************************************************
void CMeshDome::Update(void)
{
}

//*************************************************************************************************
// 描画処理
//*************************************************************************************************
void CMeshDome::Draw(void)
{
    //変数宣言-------------------------------------------------------------------------------------
    int nNumVertex;                             //頂点数
    int nPrimitiveCount;                        //プリミティブ数
    //変数宣言終了---------------------------------------------------------------------------------

    //Direct3Dデバイスの取得
    LPDIRECT3DDEVICE9 pDevice = CRenderer::GetDevice ( );

    //Direct3DデバイスのNULLチェック
    if ( pDevice != NULL )
    {
        //頂点バッファを設定(ストリーム)
        pDevice->SetStreamSource ( 0, m_pVtxBuffer, 0, sizeof ( VERTEX_3D ) );

        //頂点フォーマットの設定
        pDevice->SetFVF(FVF_VERTEX_3D);

        //デバイスにインデックスバッファの設定
        pDevice->SetIndices ( m_pIdxBuffer );

        //テクスチャの設定
        pDevice->SetTexture ( 0, m_pTexture );

        //描画をしたい頂点数とインデックス数の設定
        nNumVertex = (m_nV+1) * (m_nU);
        nPrimitiveCount = m_nV * ( DEGENERATE_NUM * m_nU + 4 ) - 4;

        pDevice->SetRenderState ( D3DRS_LIGHTING, FALSE );   //ライトを全体を有効にする

        //プリミティブの描画
        pDevice->DrawIndexedPrimitive ( D3DPT_TRIANGLESTRIP,    //プリッミティブの種類
            0,                                                  //オフセット(インデックス)
            0,                                                  //最小の頂点インデックス
            nNumVertex,                                         //頂点数
            0,                                                  //スタートインデックス
            nPrimitiveCount );                                  //プリミティブ数

        pDevice->SetRenderState ( D3DRS_LIGHTING, TRUE );   //ライトを全体を有効にする
    }
}

//*************************************************************************************************
// 自身を生成
//*************************************************************************************************
CMeshDome *CMeshDome::Create ( D3DXVECTOR3 CenterPos, float Radius, int U, int V, int nPriority )
{
    CMeshDome *pMeshDome;                     //シーン２Dクラスのポインタ

    //動的確保
    pMeshDome = new CMeshDome( nPriority );

    //各種初期化
    pMeshDome->m_Pos = CenterPos;
    pMeshDome->m_fRadius = Radius;
    pMeshDome->m_nU = U;
    pMeshDome->m_nV = V;

    //初期化処理
    pMeshDome->Init ( );

    return pMeshDome;
}