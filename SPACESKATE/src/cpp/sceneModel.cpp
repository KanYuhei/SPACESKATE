//*************************************************************************************************
// シーンモデル処理 (sceneModel.cpp)
// Author : YUHEI KAN
//*************************************************************************************************

//*************************************************************************************************
// インクルードファイル
//*************************************************************************************************
#include "scene.h"
#include "sceneModel.h"
#include "manager.h"

//*************************************************************************************************
// マクロ定義 
//*************************************************************************************************

//*************************************************************************************************
// 構造体
//*************************************************************************************************

//*************************************************************************************************
// クラス
//*************************************************************************************************

//*************************************************************************************************
// グローバル変数
//*************************************************************************************************

//*************************************************************************************************
// プロトタイプ宣言
//*************************************************************************************************

//*************************************************************************************************
// シーンモデルのコンストラクタ
//*************************************************************************************************
CSceneModel::CSceneModel ( SCENE_TYPE type, int nPriority ):CScene( type, nPriority )
{
    m_pMesh = NULL;
    m_pBuffMat = NULL;
    for ( int i = 0; i < MDEL_TEXTURE_NUM; i++ )
    {
        m_pTexture[i] = NULL;
    }
    m_nNumMat = (DWORD)0;

    m_Pos = D3DXVECTOR3 ( 0.0f, 0.0f, 0.0f );
    m_Scl = D3DXVECTOR3 ( 0.0f, 0.0f, 0.0f );
    m_Rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

    //クォータニオンの単位行列を作る関数
    D3DXQuaternionIdentity ( &m_Quaternion );
}

//*************************************************************************************************
// シーンモデルのデストラクタ
//*************************************************************************************************
CSceneModel::~CSceneModel ()
{
}

//*************************************************************************************************
// 初期化処理
//*************************************************************************************************
HRESULT CSceneModel::Init(void)
{
    return S_OK;
}

//*************************************************************************************************
// 終了処理
//*************************************************************************************************
void CSceneModel::Uninit(void)
{
    //メッシュ情報インターフェースの解放
    if ( m_pMesh != NULL )
    {
        m_pMesh->Release();
        m_pMesh = NULL;
    }

    //マテリアル情報の解放
    if ( m_pBuffMat != NULL )
    {
        m_pBuffMat->Release();
        m_pBuffMat= NULL;
    }
}

//*************************************************************************************************
// 更新処理
//*************************************************************************************************
void CSceneModel::Update(void)
{
}

//*************************************************************************************************
// 描画処理
//*************************************************************************************************
void CSceneModel::Draw(void)
{
    //Direct3Dデバイスの取得
    LPDIRECT3DDEVICE9 pDevice = CRenderer::GetDevice ( );

    //Direct3DデバイスのNULLチェック
    if ( pDevice != NULL )
    {
        D3DMATERIAL9 matDef;

        //現在デバイスに設定されているマテリアル情報を取得
        pDevice->GetMaterial ( &matDef );

        D3DXMATRIX mtxWorld;                    //ワールド行列
        D3DXMATRIX mtxSclModel;                 //拡大行列
        D3DXMATRIX mtxRotModel;                 //回転行列
        D3DXMATRIX mtxPosModel;                 //平行移動行列

        //単位行列を作る関数
        D3DXMatrixIdentity ( &mtxWorld );

        //拡大行列を作る関数
        D3DXMatrixScaling ( &mtxSclModel, m_Scl.x, m_Scl.y, m_Scl.z );

        //回転行列を作る関数
        //D3DXMatrixRotationQuaternion ( &mtxRotModel, &m_Quaternion );
        D3DXMatrixRotationYawPitchRoll(&mtxRotModel, m_Rot.y, m_Rot.x, m_Rot.z);

        //平行移動行列を作る関数
        D3DXMatrixTranslation ( &mtxPosModel, m_Pos.x, m_Pos.y, m_Pos.z );

        //ワールドマトリクスに掛け算(拡大→回転→平行移動)
        mtxWorld *= mtxSclModel;
        mtxWorld *= mtxRotModel;
        mtxWorld *= mtxPosModel;

        //デバイスにワールドマトリクスを設定
        pDevice->SetTransform ( D3DTS_WORLD, &mtxWorld );

        D3DXMATERIAL* pMat;
        pMat = (D3DXMATERIAL*)m_pBuffMat->GetBufferPointer( );

        //マテリアル情報の数分繰り返す
        for ( int i = 0; i < (int)m_nNumMat; i++ )
        {
            //マテリアルの設定
            pDevice->SetMaterial ( &pMat[i].MatD3D );

            //テクスチャの設定
            pDevice->SetTexture ( 0, m_pTexture[i] );
            
            //メッシュの描画
            m_pMesh->DrawSubset ( i );
        }

        //マテリアルの設定
        pDevice->SetMaterial ( &matDef );

        //単位行列を作る関数
        D3DXMatrixIdentity ( &mtxWorld );

        //デバイスにワールドマトリクスを設定
        pDevice->SetTransform ( D3DTS_WORLD, &mtxWorld );
    }
}

//*************************************************************************************************
// Xファイルの読み込み
//*************************************************************************************************
HRESULT CSceneModel::LoadX(const char *filename)
{
    //Direct3Dデバイスの取得
    LPDIRECT3DDEVICE9 pDevice = CRenderer::GetDevice();

    //Direct3DデバイスのNULLチェック
    if (pDevice != NULL)
    {
        //モデルの読み込み
        if (FAILED(D3DXLoadMeshFromX(
            filename,                           //読み込むXファイル名
            D3DXMESH_MANAGED,                   //頂点/インデックス・バッファをシステム・メモリ上に作る
            pDevice,                            //メッシュ描画に使うデバイス
            NULL,                               //Xファイルの隣接情報
            &m_pBuffMat,                        //Xファイルのマテリアル情報
            NULL,                               //
            &m_nNumMat,                         //マテリアル情報の数
            &m_pMesh)))                         //メッシュ情報インターフェース
        {
            MessageBox(NULL, "モデルの読み込みに失敗しました", "終了メッセージ", MB_OK);
            return E_FAIL;
        }
    }

    //マテリアル情報バッファのポインタ取得
    D3DXMATERIAL* pMat = (D3DXMATERIAL*)m_pBuffMat->GetBufferPointer();

    //各マテリアル情報を保存
    for (int i = 0; i < (int)m_nNumMat; i++)
    {
        if (pMat[i].pTextureFilename == NULL) continue;

        //テクスチャの読み込み
        if (FAILED(D3DXCreateTextureFromFile(pDevice, pMat[i].pTextureFilename, &m_pTexture[i])))
        {
            MessageBox(NULL, "テクスチャの読み込みに失敗しました", "終了メッセージ", MB_OK);
            return E_FAIL;
        }
    }

    return S_OK;
}

//*************************************************************************************************
// 拡大の取得
//*************************************************************************************************
D3DXVECTOR3 CSceneModel::GetScl ( void )
{
    return m_Scl;
}

//*************************************************************************************************
// 回転の取得
//*************************************************************************************************
D3DXVECTOR3 CSceneModel::GetRot(void)
{
    return m_Rot;
}

//*************************************************************************************************
// 拡大の設定
//*************************************************************************************************
void CSceneModel::SetScl ( D3DXVECTOR3 Scl )
{
    m_Scl = Scl;
}

//*************************************************************************************************
// 回転の設定
//*************************************************************************************************
void CSceneModel::SetRot(D3DXVECTOR3 Rot)
{
    m_Rot = Rot;
}